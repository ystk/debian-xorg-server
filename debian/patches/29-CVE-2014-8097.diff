From 2ef42519c41e793579c9cea699c866fee3d9321f Mon Sep 17 00:00:00 2001
From: Alan Coopersmith <alan.coopersmith@oracle.com>
Date: Wed, 22 Jan 2014 23:12:04 -0800
Subject: dbe: unvalidated lengths in DbeSwapBuffers calls [CVE-2014-8097]

ProcDbeSwapBuffers() has a 32bit (n) length value that it uses to read
from a buffer. The length is never validated, which can lead to out of
bound reads, and possibly returning the data read from out of bounds to
the misbehaving client via an X Error packet.

SProcDbeSwapBuffers() swaps data (for correct endianness) before
handing it off to the real proc.  While doing the swapping, the
length field is not validated, which can cause memory corruption.

v2: reorder checks to avoid compilers optimizing out checks for overflow
that happen after we'd already have done the overflowing multiplications.

Reported-by: Ilja Van Sprundel <ivansprundel@ioactive.com>
Signed-off-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Peter Hutterer <peter.hutterer@who-t.net>

[hertzog@debian.org: Backported to apply on version 1.7. Also include
upstream fix-up commit:
http://cgit.freedesktop.org/xorg/xserver/commit/?id=b20912c3d45cbbde3c443e6c3d9e189092fe65e1
]
--- a/dbe/dbe.c
+++ b/dbe/dbe.c
@@ -489,8 +489,9 @@ ProcDbeSwapBuffers(ClientPtr client)
     DbeSwapInfoPtr	swapInfo;
     xDbeSwapInfo	*dbeSwapInfo;
     int			error;
-    register int	i, j;
-    int			nStuff;
+    unsigned int	i, j;
+    unsigned int	nStuff;
+    int			nStuff_i;
 
 
     REQUEST_AT_LEAST_SIZE(xDbeSwapBuffersReq);
@@ -498,11 +499,13 @@ ProcDbeSwapBuffers(ClientPtr client)
 
     if (nStuff == 0)
     {
+	REQUEST_SIZE_MATCH(xDbeSwapBuffersReq);
         return(Success);
     }
 
     if (nStuff > UINT32_MAX / sizeof(DbeSwapInfoRec))
 	    return BadAlloc;
+    REQUEST_FIXED_SIZE(xDbeSwapBuffersReq, nStuff * sizeof(xDbeSwapInfo));
 
     /* Get to the swap info appended to the end of the request. */
     dbeSwapInfo = (xDbeSwapInfo *)&stuff[1];
@@ -574,10 +577,11 @@ ProcDbeSwapBuffers(ClientPtr client)
      * could deal with cross-screen synchronization.
      */
 
-    while (nStuff > 0)
+    nStuff_i = nStuff;
+    while (nStuff_i > 0)
     {
         pDbeScreenPriv = DBE_SCREEN_PRIV_FROM_WINDOW(swapInfo[0].pWindow);
-        error = (*pDbeScreenPriv->SwapBuffers)(client, &nStuff, swapInfo);
+        error = (*pDbeScreenPriv->SwapBuffers)(client, &nStuff_i, swapInfo);
         if (error != Success)
         {
             Xfree(swapInfo);
@@ -1049,7 +1053,7 @@ static int
 SProcDbeSwapBuffers(ClientPtr client)
 {
     REQUEST(xDbeSwapBuffersReq);
-    register int	i, n;
+    unsigned int	i, n;
     xDbeSwapInfo	*pSwapInfo;
 
 
@@ -1057,6 +1061,9 @@ SProcDbeSwapBuffers(ClientPtr client)
     REQUEST_AT_LEAST_SIZE(xDbeSwapBuffersReq);
 
     swapl(&stuff->n, n);
+    if (stuff->n > UINT32_MAX / sizeof(DbeSwapInfoRec))
+	return BadAlloc;
+    REQUEST_FIXED_SIZE(xDbeSwapBuffersReq, stuff->n * sizeof(xDbeSwapInfo));
 
     if (stuff->n != 0)
     { 
