From: Peter Hutterer <peter.hutterer@who-t.net>
Date: Tue, 29 Nov 2022 13:55:32 +1000
Subject: Xi: disallow passive grabs with a detail > 255
Origin: https://gitlab.freedesktop.org/xorg/xserver/commit/a6c0d7b142e762a6b9934a23e060ea91ff5afcea
Bug-Debian-Security: https://security-tracker.debian.org/tracker/CVE-2022-46341
Bug-Debian: https://bugs.debian.org/1026071

The XKB protocol effectively prevents us from ever using keycodes above
255. For buttons it's theoretically possible but realistically too niche
to worry about. For all other passive grabs, the detail must be zero
anyway.

This fixes an OOB write:

ProcXIPassiveUngrabDevice() calls DeletePassiveGrabFromList with a
temporary grab struct which contains tempGrab->detail.exact = stuff->detail.
For matching existing grabs, DeleteDetailFromMask is called with the
stuff->detail value. This function creates a new mask with the one bit
representing stuff->detail cleared.

However, the array size for the new mask is 8 * sizeof(CARD32) bits,
thus any detail above 255 results in an OOB array write.

CVE-2022-46341, ZDI-CAN 19381

This vulnerability was discovered by:
Jan-Niklas Sohn working with Trend Micro Zero Day Initiative

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
Acked-by: Olivier Fourdan <ofourdan@redhat.com>
(cherry picked from commit 51eb63b0ee1509c6c6b8922b0e4aa037faa6f78b)
---
 Xi/xipassivegrab.c | 22 ++++++++++++++--------
 1 file changed, 14 insertions(+), 8 deletions(-)

Index: xorg-server-1.20.4/Xi/xipassivegrab.c
===================================================================
--- xorg-server-1.20.4.orig/Xi/xipassivegrab.c	2022-12-30 01:49:29.038991611 +0100
+++ xorg-server-1.20.4/Xi/xipassivegrab.c	2022-12-30 01:49:29.038991611 +0100
@@ -133,6 +133,12 @@
         return BadValue;
     }
 
+    /* XI2 allows 32-bit keycodes but thanks to XKB we can never
+     * implement this. Just return an error for all keycodes that
+     * cannot work anyway, same for buttons > 255. */
+    if (stuff->detail > 255)
+        return XIAlreadyGrabbed;
+
     if (XICheckInvalidMaskBits(client, (unsigned char *) &stuff[1],
                                stuff->mask_len * 4) != Success)
         return BadValue;
@@ -312,6 +318,12 @@
         client->errorValue = stuff->detail;
         return BadValue;
     }
+
+    /* We don't allow passive grabs for details > 255 anyway */
+    if (stuff->detail > 255) {
+        client->errorValue = stuff->detail;
+        return BadValue;
+    }
 
     rc = dixLookupWindow(&win, stuff->grab_window, client, DixSetAttrAccess);
     if (rc != Success)
